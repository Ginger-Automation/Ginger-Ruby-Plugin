using Amdocs.Ginger.Plugin.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace GingerRubyPluginConsole
{
    public class RubyExecution
    {
        IGingerAction mGingerAction = null;
        public IGingerAction GingerAction
        {
            get
            {
                return mGingerAction;
            }
            set
            {
                mGingerAction = value;
                if (mGingerAction != null)
                {
                    mGingerAction.AddExInfo("\n");
                }
            }
        }

        string mOutputs = string.Empty;

        public enum eExecutionMode { ScriptPath, FreeCommand }
        public eExecutionMode ExecutionMode;

        public List<RubyPrameters> RubyPrameters = new List<RubyPrameters>();

        static string mCommandOutputErrorBuffer = string.Empty;
        static string mCommandOutputBuffer = string.Empty;

        string mRubyScriptPath = null;
        public string RubyScriptPath
        {
            get
            {
                return mRubyScriptPath;
            }
            set
            {
                mRubyScriptPath = value;
            }
        }
        string mDelimeter = null;
        public string Delimeter
        {
            get
            {
                return mDelimeter;
            }
            set
            {
                mDelimeter = value;
            }
        }
        public void Execute()
        {
            Console.WriteLine("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Execution Started %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
            try
            {
                switch(ExecutionMode)
                {
                    case eExecutionMode.ScriptPath:
                        CommandElements command = new CommandElements();                       
                        command = PrepareCommand();
                        ExecuteCommand(command);
                        ParseCommandOutput();
                        break;
                }
            }
            catch(Exception ex)
            {
                GingerAction.AddError("Error while executing script : " + ex.ToString());
            }
        }

        public static bool OutputParamExist(GingerAction GA, string paramName, string paramValue = null)
        {
            IGingerActionOutputValue val = null;
            if (paramValue == null)
            {
                val = GA.Output.OutputValues.Where(x => x.Param == paramName).FirstOrDefault();
            }
            else
            {
                val = GA.Output.OutputValues.Where(x => x.Param == paramName && x.Value.ToString() == paramValue).FirstOrDefault();
            }

            if (val == null)
            {
                return false;
            }
            else
            {
                return true;
            }
        }


        private CommandElements PrepareCommand()
        {
            string Arguments = string.Empty;
            CommandElements command = new CommandElements();            
            command.ExecuterFilePath = "ruby";                   
            Arguments += string.Format("\"{0}\"", RubyScriptPath) ;
            if(RubyPrameters != null)
            {
                foreach (RubyPrameters gp in RubyPrameters)
                {
                    Arguments += " " + gp.Value;
                }
            }            
            command.Arguments = Arguments;
            return command;
        }


        public void SetContent(String content)
        {
            try
            {
                RubyScriptPath = System.IO.Path.GetTempFileName().Replace(".tmp", ".rb");
                StreamWriter sw = new StreamWriter(RubyScriptPath);
                sw.Write(content);
                sw.Close();
            }
            catch (Exception e)
            {
                Console.WriteLine("Failed to create ruby file");
                throw e;
            }            
        }

        static protected void AddCommandOutput(string output)
        {
            mCommandOutputBuffer += output + "\n";
            Console.WriteLine(output);
        }
        static protected void AddCommandOutputError(string error)
        {
            mCommandOutputErrorBuffer += error + "\n";
            Console.WriteLine(error);
        }
        protected void Process_Exited(object sender, EventArgs e)
        {           
            Console.WriteLine("Command Execution Ended");
        }
        private void ParseCommandOutput()
        {
            try
            {
                //Error
                if (!string.IsNullOrEmpty(mCommandOutputErrorBuffer.Trim().Trim('\n')))
                {                                        
                    GingerAction.AddError(string.Format("Console Errors: \n{0}", mCommandOutputErrorBuffer));                    
                }

                //Output values
                Regex rg = new Regex(@"Microsoft.*\n.*All rights reserved.");
                string stringToProcess = rg.Replace(mCommandOutputBuffer, "");
                string[] values = stringToProcess.Split('\n');
                foreach (string dataRow in values)
                {
                    if (dataRow.Length > 0) // Ignore empty lines
                    {
                        string param;
                        string value;
                        int signIndex = -1;
                        if (string.IsNullOrEmpty(mDelimeter))
                        {
                            signIndex = dataRow.IndexOf("=");
                        }
                        else
                        {
                            signIndex = dataRow.IndexOf(mDelimeter);
                        }
                        if (signIndex > 0)
                        {
                            param = dataRow.Substring(0, signIndex);
                            //the rest is the value
                            value = dataRow.Substring(param.Length + 1);
                            GingerAction.AddOutput(param, value, "Console Output");
                        }
                        //TODO: Add the result to Action output values
                    }
                }
            }
            catch (Exception ex)
            {                
                GingerAction.AddError(string.Format("Failed to parse all command console outputs, Error:'{0}'", ex.Message));
            }
        }
        
        public void ExecuteCommand(object commandVal)
        {
            try
            {
                //CommandElements commandVals = (CommandElements)commandVal;
                //Process process = new Process();
                //if (commandVals.WorkingFolder != null)
                //{
                //    process.StartInfo.WorkingDirectory = commandVals.WorkingFolder;
                //}

                //process.StartInfo.FileName = commandVals.ExecuterFilePath;
                //process.StartInfo.Arguments = commandVals.Arguments;

                //process.StartInfo.CreateNoWindow = true;
                //process.StartInfo.UseShellExecute = false;
                //process.StartInfo.RedirectStandardOutput = true;
                //process.StartInfo.RedirectStandardError = true;
                //mCommandOutputBuffer = string.Empty;
                //mCommandOutputErrorBuffer = string.Empty;
                //process.OutputDataReceived += (proc, outLine) => { AddCommandOutput(outLine.Data); };
                //process.ErrorDataReceived += (proc, outLine) => { AddCommandOutputError(outLine.Data); };
                //process.Exited += Process_Exited;
                //Console.Write("--Staring process");
                //process.Start();
                //Stopwatch stopwatch = Stopwatch.StartNew();
                //process.BeginOutputReadLine();

                //process.BeginErrorReadLine();

                //int maxWaitingTime = 1000 * 60 * 60;//TODO: User defined

                //process.WaitForExit(maxWaitingTime);
                //Console.Write("--Process done");
                //stopwatch.Stop();

                //if (stopwatch.ElapsedMilliseconds >= maxWaitingTime)
                //{
                //    GingerAction.AddError("Command processing timeout has reached!");
                //}
                
                CommandElements commandVals = (CommandElements)commandVal;
                ProcessStartInfo processStartInfo = new ProcessStartInfo();
                processStartInfo.FileName = commandVals.ExecuterFilePath;
                processStartInfo.Arguments = commandVals.Arguments;
                processStartInfo.RedirectStandardOutput = true;
                processStartInfo.UseShellExecute = false;
                using (Process process = Process.Start(processStartInfo))
                {
                    process.WaitForExit();
                }
            }
            catch (Exception ex)
            {
                GingerAction.AddError("Failed to execute the command, Error is: '{0}'" + ex.Message);
                Console.Write(ex.Message);
            }
            finally
            {
                GingerAction.AddExInfo("--Exiting execute command");
            }
            
        }
        private void Process_ErrorDataReceivedAsync(object sender, DataReceivedEventArgs e)
        {
            mOutputs += e.Data + System.Environment.NewLine;
        }

        private void Process_OutputDataReceivedAsync(object sender, DataReceivedEventArgs e)
        {
            mOutputs += e.Data + System.Environment.NewLine;
        }
    }
}
